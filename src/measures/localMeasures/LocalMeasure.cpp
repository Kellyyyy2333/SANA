#include "LocalMeasure.hpp"
#include <vector>
#include <iostream>

using namespace std;

//is this folder actually ever used? -Nil
const string LocalMeasure::autogenMatricesFolder = "autogenerated/matrices/";

LocalMeasure::LocalMeasure(const Graph* G1, const Graph* G2, const string& name) : Measure(G1, G2, name) {
    createFolder(autogenMatricesFolder);
}

LocalMeasure::~LocalMeasure() {
}

double LocalMeasure::eval(const Alignment& A) {
    uint n = G1->getNumNodes();
    double similaritySum = 0;
    for (uint i = 0; i < n; i++) {
        similaritySum += sims[i][A[i]];
    }
    return similaritySum/n;
}

bool LocalMeasure::isLocal() {
    return true;
}

vector<vector<float> >* LocalMeasure::getSimMatrix() {
    return &sims;
}

void LocalMeasure::loadBinSimMatrix(string simMatrixFileName) {
    cout << "Computing " << simMatrixFileName << " ... ";
    Timer T;
    T.start();
    initSimMatrix();
    cout << "Loading binary sim matrix done (" << T.elapsedString() << ")" << endl;
}

void LocalMeasure::writeSimsWithNames(string outfile) {
    const vector<string>* mapG1 = G1->getNodeNames();
    const vector<string>* mapG2 = G2->getNodeNames();
    ofstream fout(outfile);
    for (uint i = 0; i < G1->getNumNodes(); i++) {
        for (uint j = 0; j < G2->getNumNodes(); j++) {
            fout << (*mapG1)[i] << " " << (*mapG2)[j] << " " << sims[i][j] << endl;
        }
    }
}

//outputs the weight this measure should be multiplied by to scale kind of close to 0 through 1
double LocalMeasure::balanceWeight(){
    double totalSim = 0;
    uint simNumber = 0;
    for(uint i = 0; i < sims.size(); i++){
        for(uint j = 0; j < sims[i].size(); j++){
            totalSim += sims[i][j];
            simNumber++;
        }
    }
    double averageSim = totalSim/simNumber;
    return .5/averageSim; //average sim is scaled to one half
}
